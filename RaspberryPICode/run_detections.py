from gpiozero import LED
import time
import random
import cv2
from ultralytics import YOLO
from ultralytics.utils.plotting import Annotator
import os

#### Setup the environment to send emails on detection of the fire/gas
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.base import MIMEBase
from email import encoders
import os

# Configuration
port = 587
smtp_server = "live.smtp.mailtrap.io"
login = "api"  # Your login generated by Mailtrap
password = "5f61752a6ca796c82afc51eb5c809495"  # Your password generated by Mailtrap

sender_email = "shriyaonfire@demomailtrap.com"
receiver_email = "shriyaonfire@gmail.com"

# HTML content with an image embedded
html = """\
<html>
  <body>
    <p>FIRE ALERT!!!<br>
    This is a <b>fire alert</b> email with an embedded image.<br>
    <img src="cid:image1">.</p>
  </body>
</html>
"""

# Create a multipart message and set headers
message = MIMEMultipart()
message["From"] = sender_email
message["To"] = receiver_email
message["Subject"] = "Fire Detected!!!"

# Attach the HTML part
message.attach(MIMEText(html, "html"))

###
### Export the environment variable export GPIOZERO_PIN_FACTORY=mock to get around the No Pin Factory found error.
###
###
from gpiozero import DigitalInputDevice
from PIL import Image

LED_LINE_OFFSET_NOFIRE = 17
LED_LINE_OFFSET_FIRE = 27
CONFIDENCE_PERCENT = 0.8

led_nofire = LED(LED_LINE_OFFSET_NOFIRE)
led_fire = LED(LED_LINE_OFFSET_FIRE)

# Initialize the gas sensor module
# It is connected to the GPIO26 pin.
# Flame sensor is connected to the GPIO19 Pin.

mq2 = DigitalInputDevice(19)
flame_sensor = DigitalInputDevice(26)

flame_danger_detected = False
gas_dander_detected = False
camera_danger_detected = False

ROOT_PATH = '/home/sowmyavenky/ShriyaOnFire/training/runs/detect/train3/weights/'

BEST_PT = os.path.join(ROOT_PATH, 'best.pt')

# Load the YOLOv8 model
model = YOLO(BEST_PT)

cap = cv2.VideoCapture(0)

cap.set(3, 640)
cap.set(4, 480)

dangers_detected_counter = 0 

try:
    while True:
        # Flame based checks.
        if flame_sensor.is_active:
            # print('No flame is detected')
            flame_danger_detected = False
        else:
            # print('DETECTED A FLAME!!!')
            flame_danger_detected = True
            
        # Gas sensor checks.
        if mq2.value == 0:
            # print("GAS LEAK DETECTED")
            gas_danger_detected = True
        else:
            # print('No gas leak is detected')
            gas_danger_detected = False
        
        ret, frame1 = cap.read()
        frame = cv2.resize(frame1, (640, 480)) 
        
        results = model.predict(source=frame) 

        for r in results:        
          annotator = Annotator(frame)            
          boxes = r.boxes
          
          if len(boxes) > 0:
              camera_danger_detected = True
          else:
              camera_danger_detected = False

          for box in boxes:
            b = box.xyxy[0]  # get box coordinates in (left, top, right, bottom) format
            c = box.cls
            annotator.box_label(b, model.names[int(c)], color=(0, 255, 0),txt_color=(0, 0, 255),)

        # If flame or gas or camera danger, overall danger is detected.
        danger_detected = camera_danger_detected | gas_danger_detected | flame_danger_detected

        img = annotator.result()  

        if danger_detected:
            dangers_detected_counter = dangers_detected_counter + 1 
            print('******** ONE OR MORE Dangers Detected **********')
            if camera_danger_detected:
                print("Camera Detected a flame.")

            if gas_danger_detected:
                print("Gas sensor detected a gas leak.")

            if flame_danger_detected:
                print("Flame sensor detected a flame.")
            led_nofire.off()
            led_fire.on()

            # Send an email message every 100 persistent errors...
            if dangers_detected_counter % 100 == 0:
              retval = cv2.imwrite('captured_image.jpg', img)
              img = open('captured_image.jpg', 'rb')
              msg_img = MIMEImage(img.read(), name='captured_image.jpg')
              msg_img.add_header('Content-ID', '<image1>')
              # Attach the image to the message
              message.attach(msg_img)

              # Send the email
              with smtplib.SMTP(smtp_server, port) as server:
                server.starttls()
                server.login(login, password)
                server.sendmail(sender_email, receiver_email, message.as_string())
                dangers_detected_counter = 0
        else:
            dangers_detected_counter = 0
            print('No Dangers Detected')
            led_nofire.on()
            led_fire.off()
            
        #time.sleep(1)

        
        cv2.imshow('Fire Detection', img)   

        if cv2.waitKey(10) & 0xFF == ord('q'):
            break

finally:
    cap.release()
    cv2.destroyAllWindows()

    
